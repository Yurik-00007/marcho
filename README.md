В html есть 2 вида тегов блочный и строчные проще запомнить строчные такие как картинка-img, ссылка, span
и те файлы которые входят в форму это input, select, textarea. Теги могут быть как самозакрывающиеся так и одиночные

--------------------------------места css--------------------------------------------------

Каскаднная таблицы стилей css можно писать в 3 разных местах

1. inline стили когда пишется прямо в строку (❗имеют наивысший приоритет)
   <h5 style="text-align: center; color:tomato;">Привет!</h5>
2. когда пишется в тег после тега <body>

<style>
p{ text-align: center; }
</style>

3. И самый правильный и распространенный когда пишется в отдельный файл в теги <header>
    <link rel="stylesheet" href="css/style.css">

--------------------------------селектор--------------------------------------------------

1. Использование классов в HTML позволяет легко и эффективно применять одинаковые стили ко множеству элементов на
   веб-странице.
   Класс это имя которое используется в css в качестве селектора, но только с точкой(селектор класса).
   <span class="content">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ad, quos.</span> -html

<div class="content">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ad, quos.</div> - html
.content{ font-size: 35px; } - css

2. Так же бывает селектор тега
   <h3>Привет!</h3> - html
   h3{ text-align: center; color:tomato; } - css
3. Так же бывает селектор идентификатора

<p id="text1">lorem </p> - html
    #text1{ font-style: italic; } -css

--------------------------------стили по умолчанию--------------------------------------------------

1. Стили по умолчанию нужно сбрасывать для этого есть сайт, где все это указано
   http://html5doctor.com/html-5-reset-stylesheet/
2. Создается отдельный файл(reset.css) и туда все это добро записывается
3. Важно помнить о приоритетности когда подключаем свои стили(style.css) он должны быть в конце тогда приоритет будет -
   выше
4. А reset.css должен быть выше тогда приоритет - ниже
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/style.css">

--------------------------------Схлопывание отступов margin--------------------------------------------------

Схлопывание отступов (margin collapsing) — это особенность CSS, которая влияет на вертикальные отступы (margin) между
блоками. Эта особенность заключается в том, что когда два вертикальных отступа встречаются, они "схлопываются" в один,
равный наибольшему из отступов, а не суммируются.

--------------------------------отрицательное значение margin--------------------------------------------------

Когда у свойства margin в CSS есть отрицательное значение, это означает, что соответствующий элемент будет перемещаться
в противоположном направлении, по сравнению с положительным значением отступа.
margin-top: -87px;

--------------------------------горизонтального центрирования блока margin: 0
auto--------------------------------------------------

Свойство margin: 0 auto; часто используется для горизонтального центрирования блока (обёртки) внутри его родительского
контейнера.

--------------------------------размеров элемента box-sizing:
border-box--------------------------------------------------

Свойство box-sizing: border-box; в CSS изменяет модель расчета размеров элемента. Это свойство определяет, как
вычисляются размеры элемента, включая его ширину и высоту.
В этом режиме размеры элемента включают области содержимого, внутренние отступы и границы.
Указанные размеры элемента являются его общими размерами (ширина и высота). А контент сужается, чтобы соответствовать.
Записывается общие стили.
пример:
*{ box-sizing: border-box; }

--------------------------------отображением содержания overflow:
hidden--------------------------------------------------

Свойство overflow управляет отображением содержания блочного элемента, если оно целиком не помещается и выходит за
область заданных размеров.
overflow: auto | hidden | scroll | visible-по умолчанию

hidden
Отображается только область внутри элемента, остальное будет скрыто.
auto
Полосы прокрутки добавляются только при необходимости.

---------------------------------------------Псевдоклассы ---------------------------------------------

Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние.
Псевдоклассы:

1. :active-> Когда пользователь нажимает на элемент.
2. :hover-> Когда указатель мыши находится над элементом.
3. :focus->При навигации с помощью клавиатуры или клике на элемент.
4. :first-child-> Этот псевдокласс применяется к первому дочернему элементу родителя.
5. :last-child->Этот псевдокласс применяется к последнему дочернему элементу родителя
6. :nth-child(n/odd/even)->Этот псевдокласс применяется к элементам на основе их позиции в группе братских элементов.
7. :nth-of-type(n)->Этот псевдокласс работает аналогично :nth-child, но учитывает только элементы определенного типа.
8. :required->то есть обязательные для заполнения,
9. :checked->Этот псевдокласс применяется к элементам типа чекбоксов или радиокнопок, которые выбраны (отмечены),
10. :disabled-> Этот псевдокласс применяется к элементам, которые отключены (неактивны).
11. :not()->Этот псевдокласс выбирает элементы, которые не соответствуют указанному селектору.

    ---------------------------------------------Псевдоэлементы ---------------------------------------------

Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть
выбранного элемента. Псевдоэлементобязательно должен содержать content: '' и display: inline-block;

	Псевдоэлементы:
		1. ::before
		Псевдоэлемент before вставляет текст перед элементом. Используется только совместно со свойством content,
		которое задает текст, который следует вставить. И display: inline-block; который говорит что объект должен иметь
		область видимости
		2. ::after
		3. ::placeholder

пример:
.title-1:hover::before {
content: '';
width: 30px;
height: 30px;
border-radius: 50%;
background: #000;
top: 50px;
left: 490px;
position: absolute;
}

---------------------------------------------Позиционирование(position) ---------------------------------------------

position: static/relative/absolute/fixed;
top, left, right, bottom
В CSS свойства position и top, left, right, bottom используются для управления расположением элементов на веб-странице.

1. position: static - значение по умолчанию. Элементы с position: static расположены в нормальном потоке документа.
   Свойства top, left, right, bottom для них не применяются.
2. position: relative - элемент с position: relative располагается относительно своего обычного положения. Свойства
   top, left, right, bottom смещают элемент относительно его нормального положения.
3. position: absolute - элемент с position: absolute позиционируется относительно ближайшего предка с position:
   relative,
   position: absolute или position: fixed. Если такого предка нет, то относительно начального контекста (обычно
   это <html>).
4. position: fixed - элемент с position: fixed позиционируется относительно окна браузера и остается на месте даже
   при прокрутке страницы.
5. position: sticky - элемент с position: sticky в CSS используется для создания "липкого" позиционирования элементов,
   при котором элемент ведет себя как relative до тех пор, пока не достигает заданного порога (обычно верхнего или
   нижнего
   края родительского элемента или окна браузера), после чего он ведет себя как fixed.

   ---------------------------------------------Позиционирование(z-index) ---------------------------------------------

z-index - cвойство устанавливает, кто будет сверху в случае, если несколько элементов накладываются друг на друга.
Любые позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем
самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов
веб-страницы, их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых
значение
position задано как absolute, fixed или relative.

---------------------------------------------Трансформирует(transform) ---------------------------------------------

Трансформирует элемент, в частности, позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать
виды трансформаций, перечисляя функции трансформации через пробел.

transform-origin-Устанавливает координаты точки, относительно которой будет происходить трансформация элемента.

Функции трансформации:

rotate()-Поворачивает элемент в двумерном пространстве на заданный угол относительно точки трансформации, задаваемой
свойством transform-origin.

scale()-Масштабирует элемент по горизонтали и вертикали.

translate()-Сдвигает элемент на заданное значение по горизонтали и вертикали.

translateX()-Сдвигает элемент по горизонтали на указанное значение. Положительное значение сдвигает вправо,
отрицательное влево.

translateY()-Сдвигает элемент по вертикали на указанное значение. Положительное значение сдвигает вниз, отрицательное
вверх.

translateZ()-Сдвигает элемент по оси Z на указанное значение. Положительное значение сдвигает вперёд, отрицательное
назад.

Первоначально нужно задать начальные значения для transform и transform-origin(если нужно вращать) в классе и задать
animation с именем и параметрами, а потом задать @keyframes с именем и конечными значениями transform

Пример
.circle {
transform: rotate(0deg);
transform-origin: top left;
animation:5s ease .5s forwards infinite alternate translateX;
}

@keyframes translateX {
50% {
transform: rotate(360deg) translate(100px) scale(2);
}
100%{
transform: rotate(720deg) translate(0px) scale(1);
}
}

---------------------------------------------Преобразует(transition) ---------------------------------------------

В классе указывается transition а в псевдоклассе(:hover) или медиа-запросе укрываются свойства которые нужно изменить
Для того чтобы сработал transition нужно чтобы были какит-о числовые значения
.container {
width: 500px;
height: 500px;
background: tomato;
transition: font-size 1.5s linear .5s;
}
transition:  font-size 1.5s linear .5s;
свойства=all длительность=0s скорость=ease анимации=0s
property duration timing-function delay

transition можно использовать с псевдоклассами и с медиа-запросами

Универсальное свойство, которое позволяет одновременно задать значения transition-property, transition-duration,
transition-timing-function и transition-delay.

Устанавливает эффект перехода между двумя состояниями элемента, они могут быть определены с помощью псевдокласса
:hover или :active, а также динамически через JavaScript.

1.Свойство transition-delay устанавливает время ожидания перед запуском эффекта перехода.

2.Свойство transition-property устанавливает имя стилевого свойства, значение которого будет отслеживаться для
создания эффекта перехода.

3.Свойство transition-duration задаёт время в секундах или миллисекундах, сколько должна длиться анимация перехода
до её завершения.

4.Свойство transition-timing-function устанавливает, насколько быстро должно изменяться значение стилевого свойство
для которого применяется эффект перехода.

.container:hover {
background: green;
font-size: 26px;
color: white;
}

@media (max-width: 800px) {
.container {
background: yellow;
}
}
----------------------------------------------------------flex----------------------------------------------------------
display:flex ->размечает контейнер для его элементов

Свойства которые применяются непосредственно к flex-контейнеру⬇️:

flex-direction-->Свойство устанавливает направление главной и поперечной оси или, говоря другими словами, расставляет
элементы в ряд или в колонку.
Синтаксис
селектор {
flex-direction: row | row-reverse | column | column-reverse;}

row-->Главная ось направлена слева направо. Элементы расположены в ряд, по умолчанию прижаты к левому краю, их нумерация
имеет
обычный порядок - слева направо.
row-reverse-->Главная ось направлена справа налево. Элементы расположены в ряд, по умолчанию прижаты к правому краю, их
нумерация имеет обратный порядок - справа налево.
column-->Главная ось направлена сверху вниз. Элементы расположены в колонку, по умолчанию прижаты к верху, их нумерация
имеет обычный порядок - сверху вниз.
column-reverse-->Главная ось направлена снизу вверх. Элементы расположены в колонку, по умолчанию прижаты к низу, их
нумерация имеет обратный порядок - снизу вверх.

justify-content->Определяет, как браузер распределяет пространство вокруг флекс-элементов вдоль главной оси контейнера.
Синтаксис
селектор {
justify-content: flex-start | flex-end | center | space-between |
space-around | space-evenly}

flex-start->Флексы прижаты к началу строки.
flex-end -> Флексы прижаты к концу строки.
center -> Флексы выравниваются по центру строки.
space-between -> Флексы равномерно распределяются по всей строке. Первый и последний элемент прижимаются к
соответствующим краям контейнера.
space-around -> Флексы равномерно распределяются по всей строке. Пустое пространство перед первым и после последнего
элементов равно половине пространства между двумя соседними элементами.
space-evenly -> Флексы распределяются так, что расстояние между любыми двумя соседними элементами, а также перед первым
и после последнего, было одинаковым.

Свойство align-items выравнивает флекс-элементы внутри контейнера вдоль второстепенной оси направлении.
Синтаксис
селектор {
align-items: flex-start | flex-end | center | baseline | stretch}

stretch->Флексы растягиваются таким образом, чтобы занять всё доступное пространство контейнера.
baseline->Флексы выравниваются по их базовой линии(верхняя строка низ у всех flex-элементов).

flex-wrap - cвойство задает многострочную расстановку блоков по главной оси. Применяется к родительскому элементу для
flex
блоков. Входит в свойство-сокращение flex-flow.
Синтаксис
селектор {
flex-wrap: nowrap | wrap | wrap-reverse;}

nowrap-->Однострочный режим - блоки выстраиваются в одну строку.
wrap-->Блоки выстраиваются в несколько строк, если не помещаются в одну.
wrap-->reverse То же самое, что и wrap, но блоки выстраиваются в другом порядке (сначала последний, потом первый).

align-content - свойство задает выравнивание элементов вдоль поперечной оси для flex блоков и по горизонтальной оси для
гридов. Применяется к родительскому элементу. Если у нас более одной строки с элементомами то это свойство можно
применять.
Оно выравнит строки с элементами в кантейнере.
Синтаксис
селектор {
align-content: flex-start | flex-end | center | space-between | space-around;}

flex-start-->Блоки прижаты к началу поперечной (вертикальной) оси.
flex-end-->Блоки прижаты к концу поперечной (вертикальной) оси.
center-->Блоки стоят по центру поперечной (вертикальной) оси.
space-between-->Блоки распределены вдоль поперечной (вертикальной) оси, при этом первый элемент прижат к началу оси, а
последний - к концу.
space-around-->Блоки распределены вдоль поперечной (вертикальной) оси, при этом между первым блоком и началом оси,
последним блоком и концом оси такой же промежуток, как и между остальными блоками.
Однако, они не равны, как могло бы показаться: промежутки суммируются и между двумя блоками расстояние в два раза
больше, чем между блоком и началом/концом оси.

Свойства которые применяются непосредственно к flex-элементу⬇️:

align-self - Свойство align-self задает выравнивание вдоль поперечной оси для отдельно взятого flex-блока и по
вертикальной оси для отдельного элемента в флекс. По сути данное свойство представляет собой свойство align-items,
но для конкретного блока.
Синтаксис
селектор {
align-self: auto | flex-start | flex-end | center | baseline | stretch;}

flex-start-->Блоки прижаты к началу поперечной (вертикальной) оси.
flex-end-->Блоки прижаты к концу поперечной (вертикальной) оси.
center-->Блоки стоят по центру поперечной (вертикальной) оси.
space-between-->Блок выравнивается по своей базовой линии. Базовая линия (англ. baseline, или линия шрифта) - это
воображаемая линия, проходящая по нижнему краю символов без учета свисаний, например, как у букв 'ц', 'д', 'р', 'щ'.
stretch-->Блок растянут, занимая все доступное место по поперечной оси, при этом все же учитываются min-width и
max-width,
если они заданы. Если же задана ширина и высота для элемента - stretch будет проигнорирован.
auto-->Блок будет выровнен так, как задано в свойстве align-items.

order - cвойство задает порядок следования отдельно взятого flex-блока(элемента) внутри flex-контейнера.
Применяется к конкретному flex блоку. Своим значением свойство принимает положительное или отрицательное целое число.
Чем меньше число - тем раньше будет стоять элемент, независимо от расположения в HTML коде относительно других
элементов.

margin:0 auto;
Это свойство позволяет центрировать элемент отнасительно контейнера. можно сравнить с justify-content:center;
Только justify-content -это для flex-контейнера, margin:0 auto;-для flex-элемента

свойства которые применяются на родителя: display:flex,justify-content,align-items,align-content
свойства которые применяются на детей: align-self, order,flex-basis, flex-shrink,

================flex-basis, flex-grow, flex-shrink. flexbox погружение======================
https://www.youtube.com/watch?v=QuAVrIRjkjE

flex-grow(по ширине) - свойство определяет каэфициент растяжения свободного прастранства того, на сколько отдельный
flex-блок может быть больше соседних элементов, если это необходимо.
flex-grow:0->по умолчанию

https://code.mu/ru/markup/manual/css/property/flex-grow/

1.Если у элементов не задан размкер а задан только flex-grow, они распределяться равномерно отнасилельно значению
контейнера(width:900)
и элементов первого(flex-grow: 1;) и второго(flex-grow: 2;). В этом случае ширина обшего контейнера(900) поделиться
на 3 части и каждому достанеться по соответствующему значению: первому(1*300=300) и второму(2*300=600)

2.Если суммарная ширина элементов меньше ширины родителя, поэтому справа остается пустое пространство. При желании это
пустое пространство можно пропорционально разделить между нашими элементами. Это делается с помощью свойства flex-grow,
задаваемого флекс-элементам. Как это будет выглядить. Размер ширины контейнера 1000px, а размер первого и второго
flex-элемента по 200px, значит у нас образуеться пустое пространство равное 500px, его можно поделить при использование
к каждому элементу flex-grow: к первому flex-grow: 1;ко второму flex-grow: 2;. И тогда свободное пространство делиться
на 3 части и добовляеться к каждому элементу:600/3=200 первый-->200(его размер)+(200*1)=400 и
второй 200(его размер)+(200*2)=600

3.Если контент забрал все свободное место то писать flex-grow бесполезно так как он не будет работать

flex-shrink - cвойство определяет коэфициент сжатия того, насколько flex-блок(элемент) будет уменьшаться относительно
соседних элементов внутри flex-контейнера в случае недостатка свободного места.
flex-shrink:1->по умолчанию
flex-shrink:0-->flex-блок(элемент) не будет изменять размер присжатие экрана
https://code.mu/ru/markup/manual/css/property/flex-shrink/

flex-basis - свойство задает размер элемента вдоль главной оси. Это значит, что если главная ось горизонтальна - это
свойство будет задавать ширину элементов, а если вертикальна - то высоту.
flex-basis имеет приоритет над width но приоритет у него ниже чем у min-width и max-width
https://code.mu/ru/markup/manual/css/property/flex-basis/

shortcut(сокращение)
Свойство flex сокращение для flex-grow, flex-shrink и flex-basis.
https://developer.mozilla.org/ru/docs/Web/CSS/flex#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81

Пример:
flex:0 1 auto;-->по умолчанию
можно расписать так
flex-grow:0;
flex-shrink:1;
flex-basis:auto;

0 0 auto
flex: none;

Одно значение, число без единиц: flex-grow->всегда первое, если нет единиц
flex: 2;

---------------------------------------------Когда подключать script(
main.js)?-------------------------------------------

Скрипт нужно подключать перед закрывающим тегом body для того чтобы отработала страница html, а потом загрузился код JS.
Внутр тега <script> подключат ничего не нужно - этот код не сработает.

пример:
<script src="./js/main.js">
</script>
.</body>

---------------------------------------------как подключать jquery?-------------------------------------------
jquery должен быть подключён самым первым среди всех скрипров. jquery можно подключать несколькими способами:

1. Пойти не посредственно на сайт и скачать
   https://code.jquery.com/jquery-3.7.1.min.js
   и установить его самым первым среди всех тегов <script>

<script src="./js/jquery-3.7.1.min.js"></script>

2. Можно подключить jquery используя google cdn:
   https://developers.google.com/speed/libraries
   и там в первом абзаце есть как прописать тег <script>, не забывайте что установить его самым первым среди всех
   тегов <script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

---------------------------------------------Селектор по атрибуту-------------------------------------------

Селектор по атрибуту находит элемент на странице по значению либо по наличию атрибута.

Пример Скопировать ссылку "Пример"
<blockquote cite="А. С. Пушкин">
  Октябрь уж наступил — уж роща отряхает<br>
  Последние листы с нагих своих ветвей;
</blockquote>

Скопировать
Селектор ниже найдёт все цитаты (<blockquote>) с атрибутом cite:

blockquote[cite] {
background-color: #2E9AFF;
}

---------------------------------------------Селектор по атрибуту-------------------------------------------
🚩Свойство background-image задает фоновую картинку элементу. По умолчанию картинка замостит своими копиями весь блок,
однако, это поведение можно отменить с помощью свойства background-repeat.
селектор {
background-image: url(путь к картинке);
}
селектор {
background-image: none;->по умолчанию
}
url - Путь к файлу с картинкой. Название картинки может быть в двойных кавычках, одинарных и вообще без кавычек.
none - Отменяет фоновую картинку для элемента.

🚩Свойство background-repeat задает каким образом повторять фоновую картинку элемента. По умолчанию картинка повторяется
и по оси X, и по оси Y, таким образом покрывая собой всю доступную область.

селектор {
background-repeat: no-repeat | repeat-x | repeat-y | space | round | repeat ->по умолчанию;
}
no-repeat Картинка не будет повторяться вообще.
repeat-x Картинка будет повторяться по оси X.
repeat-y Картинка будет повторяться по оси Y.
repeat Картинка будет повторяться по оси X и по оси Y.
space Картинка повторится столько раз, чтобы полностью заполнить область, если это не удается, между картинками
добавляется пустое пространство.
round Картинка повторится так, чтобы в области поместилось целое число рисунков, если это не удается сделать, то фоновые
рисунки масштабируются.

🚩Свойство background-position задает местоположение фоновой картинки элемента. Местоположение можно задавать с помощью
любых единиц для размеров. Первое значение обозначает отступ слева, второе - отступ сверху.
Можно также задавать положение ключевыми словами. В этом случае порядок значений не важен. Ключевые слова для вертикали:
top, center, bottom. Ключевые слова по горизонтали: left, center, right.
селектор {
background-position: два значения через пробел;
}

🚩Свойство background-size задает размер картинки фона. Значением свойства служат любые единицы для размеров, либо
ключевые слова auto, cover или contain.

селектор { background-size: значение; } auto->по умолчанию

auto Фон будет иметь натуральный размер, такой, как реальный размер картинки фона. Если же auto задано только для одной
стороны, то по этой стороне фон будет масштабироваться так, чтобы иметь неискаженные пропорции.
cover Масштабирует картинку так, чтобы она накрыла собой весь блок с сохранением пропорций. Картинка будет стараться
поместиться целиком, но это не всегда будет получаться, поэтому какая-то ее часть будет обрезаться. Блок всегда будет
покрыт картинкой целиком.
contain Масштабирует картинку так, чтобы она целиком влезла в блок с сохранением пропорций. При этом она может занять
или всю ширину, или всю высоту (зависит от пропорций картинки и от размеров элемента). Блок в общем случае будет покрыт
картинкой не целиком (зато картинка всегда будет видна вся, хоть и в уменьшенном варианте).

.header__content{
background-image: url('../images/header-bg.jpg');
background-repeat: no-repeat;
background-position: center;
background-size: cover;
min-height: calc(100vh - 94px);
}

---------------------------------------------section-------------------------------------------

Если делать блок section-то обязательно должен быть тег от <h1> до <h2> хотя бы один.

---------------------------------------------column-count-------------------------------------------

Свойство column-count задает рекомендуемое количество колонок в многоколоночном тексте. Их реальное количество может
отличаться от заданного, в зависимости от ширины колонки и размера промежутка между ними.

селектор {
column-count: число | auto;
}

число Задает указанное количество колонок. Точнее, рекомендует браузеру использовать это количество колонок, так как их
реальное количество может отличаться от заданного, в зависимости от ширины колонки и размера промежутка между ними.
auto Браузер сам подбирает оптимальное количество колонок.

---------------------------------------------Специфичность css-------------------------------------------
html
<div id="index" class="test"></div>
css


читать css снизу вверх
---------------------------------------------------------------
Правило !importantв CSS используется для придания свойству/значению большей важности, чем обычно(❗Наивысший приоритет).

Фактически, если вы используете это !importantправило, оно переопределит ВСЕ предыдущие правила стилизации для этого
конкретного свойства этого элемента!
.test{ background: #ccc !important; }

Если написать инлаин стили, то будет 1000 баллов. Он имеет наивысший приоритет. Пишутся инлаин стили в теге который
находиться в html.
/* 1.0.0.0 */
<div id="index" class="test" style="background: #000; width: 100px;height: 100px;"></div>
/* 0.1.0.0 */
Если написать обращение по идентификатору, то будет 100 баллов
❗Но идентификатор можно использовать только один на странице и он должен быть уникальным.
/* 0.1.0.0 */
#index { background: #ccc; }
если написать обращение по классу к тегу то соответственно
будет 11 баллов
/* 0.0.1.1 */
.body div{ background: #ccc; }
если написать обращение по классу к классу то соответственно
будет 20 баллов
/* 0.0.2.0 */
.body .test{ background: #ccc; }
Это все мишура обращение по классу дает 10 баллов
/* 0.0.1.0 */
.test{ background: #ccc; }
Это обращение по тегу к вложенному тегу дает 1 балл плюс 1 балл равно 2 бала. Если будет тройная вложенность то будет 3
балла
/* 0.0.0.2 */
body div{ background-color: red; }

Это обращение по тегу дает 1 балл
/* 0.0.0.1 */
div{ background-color: blue; }

В классах то свойство которое ниже будет иметь больший приоритет чем которое выше. Это есть специфичность. Она не такая
простая. За это все есть баллы
---------------------------------------------------------------
/* 0.0.1.0 */
.test{
width: 200px;
height: 200px; background-color:
background: #ccc;
}

.test{
background: #000;
}
---------------------------------------------Текст в верхнем индексе sup-------------------------------------------

Тег sup отображает текст в верхнем индексе, то есть чуть выше линии обычного текста и шрифтом меньшего размера. Это
бывает нужно для записи математических или химических формул и так далее.
Формула квадратного уравнения: ax<sup>2</sup> + bx + c = 0.

---------------------------------------------Псевдоэлемент ::placeholder-------------------------------------------
Псевдоэлемент, с помощью которого задаётся стилевое оформление подсказывающего текста, созданного атрибутом placeholder.
Допускается использовать свойства для изменения вида текста, например, задать шрифт и цвет.

Пример:
.form input::placeholder{
font-size: 12px;
line-height: 20px;
letter-spacing: 3.71px;
text-transform: uppercase;
color: #B8B8B8;
}

---------------------------------------------Размеры текстового поля .textarea {resize:
none}-------------------------------------------

Указывает, можно ли пользователю изменять размеры текстового поля.Применяется К <textarea> или к любому элементу, у
которого свойство overflow отличается от visible
Пример:
.form textarea {
min-height: 140px;
resize: none;
}

---------------------------------------------Адаптив @media-------------------------------------------
Адаптив начинаеться с этой строчки она добовляеться автоматически и подстраивает сайт под ширину экрана устройства на
котором будет открыт сайт
<meta name="viewport"
content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

Эта медиа запрос с условием и действием, которое означат что если ширина от 0 до 1500px значит скрой body, а если больше
от 1500px условие не действует.
медиа запрос условие что сделать?
@media           (max-width: 1500px) {
body{
display: none;
}
}
---------------------------------------------Поведение прокрутки-------------------------------------------
Определяет поведение прокрутки внутри элемента — плавная прокрутка или мгновенный переход.
scroll-behavior: smooth;
но не визде работает тоже самое можно сделать с помощью jquery но нужно внести изменения в script
<script src="./js/main.js"></script>
Плавный скролл: https://webcomplex.com.ua/jquery/plavnyj-skroll-posle-nazhatiya-na-yakornuyu-ssylku.html

---------------------------------------------Почему удобно пользоваться
препроцессорами?-------------------------------------------
Препроцессоры позволяют пользоваться константами
объявление переменной через $, а далее идет имя
$default-color:tomato;

Применение переменной
.wrapper{
background: default-color;
}
============================================
& является ссылкой на родительский селектор внутри вложенного блока.
//scss
.menu{
display: flex;
&__list{ margin: 0; }
&__link{ text-decoration: none; }
}
//css
.menu {
display: flex; }
.menu__list {
margin: 0; }
.menu__link {
text-decoration: none; }
============================================
Placeholder селекторы в SCSS — это мощный инструмент для создания переиспользуемых стилей и поддержания чистоты кода.

Создаем часто повторяемый код %ИМЯ
%bg{
background-position: top center;
background-repeat: no-repeat;
background-size: cover;
}
применяем этот кусок повторения в селекторе класса @extend %ИМЯ
//scss
.about{
color: $assent;
font-family: $assent-font;

background-image: url('images/1.jpg');
@extend %bg;
}
//css
.about {
background-position: top center;
background-repeat: no-repeat;
background-size: cover;
}
.about{
color: $assent;
font-family: $assent-font;

background-image: url('images/1.jpg');
}
============================================
импорты в препроцессорах scss
создадим файл reset0.scss с кодом
ul .test{
margin: 0;
padding: 0;
}
и вызовем этот код в style1.scss c помощью 
@import "reset0";
и код будет добавлен ....
ul .test {
margin: 0;
padding: 0;
}

.about {
background-position: top center; ....

---------------------------------------------Git-------------------------------------------

// инициализируем приложение
git init
//проверяем за кем следит git
git status
// следить за всеми файлами что есть 
git add .
//проверяем за кем следит git
git status
//создать коммит(точку сохранения)
//Все изменения, которые вы хотите включить в коммит, должны быть предварительно добавлены с помощью команды git add.
Должны явно использовать git add перед коммитом.
git commit -m "first commit"
//Флаг -a автоматически индексирует все изменения в отслеживаемых файлах (файлы, которые уже отслеживаются Git), 
включая изменения и удаление этих файлов. Файлы, которые еще не отслеживаются (т.е. не были добавлены в индекс с помощью 
git add), не будут включены в коммит.
git commit -am "first commit"

//Переименовывает текущую ветку в main.
git branch -M main
//Команда git remote add origin git@github.com:Yurik-00007/reactRouterDom_ignat.git используется для добавления 
удаленного репозитория к вашему локальному репозиторию Git.
git remote add origin git@github.com:Yurik-00007/reactRouterDom_ignat.git
//Используется для отправки изменений из локальной ветки main в удаленный репозиторий origin и для установки отслеживания этой ветки.
Далее можно использовать git push для отправки новых коммитов в удаленный репозиторий.
git push -u origin main
//Используется для отображения истории коммитов в репозитории, начиная с самого последнего и заканчивая первым.
git log
//создает новую ветку dev(имя), но не переключает вас на нее
git branch dev
// Переключить в новую ветку
git checkout dev
//Показывает выбранную ветку
git branch

============================================

//файл который говорит git какие файлы игнорировать Git  
.DS_Store
.idea/
.idea/*
.vscode
*.sublime*
npm-debug.*

dist/
node_modules/
package-lock.json
app/css/*


---------------------------------------------добавление шрифтов-------------------------------------------

1. Скачиваем нужные шрифты с GoogleFonts папку app/fonts
2. Если шрифты в формате .ttf их нужно конвертировать в шрифты woff2 и woff
3. _fonts.scss прописываем каждый шрифт
   @font-face {
   font-family: 'Quicksand-Regular', sans-serif;
   font-weight: 400;
   font-style: normal;
   src: local('Quicksand-Regular'),
   url('../fonts/Quicksand-Regular.woff2') format('woff2'),
   url('../fonts/Quicksand-Regular.woff') format('woff');
   font-display: swap;
   }
4. далее идем в переменные _vars.scss и создаем переменную для шрифта(placeholder) %ИМЯ
   %quicksand-400 {
   font-family: 'Quicksand-Regular', sans-serif;
   font-weight: 400;
   }
5. теперь идем в то место где будем использовать этот шрифт например в _global.scss и прописываем его c помощью @extend %ИМЯ
   body {
   color: $default;
   font-size: 16px;
   line-height: 26px;
   font-weight: 500;
   @extend %quicksand-500;
   }
   Заключение
   @font-face определяет шрифт, который будет использоваться на веб-странице.
   %quicksand-400 — это placeholder в SASS для стилей шрифта.
   @extend %quicksand-400 позволяет любому селектору наследовать стили из этого placeholder.


---------------------------------------------редоктирование фото для логотипа-------------------------------------------
1. В photoshop выбрать инструмент перемещение
2. Выделить необходимый объект, для этого нажать левой кнопкой
3. Зажать alt+ глаз в правой панели(на странице останется логотип все остольное будет скрыто)
4. Выделить логотип(можно не прижиматься к краям, а выделить большую область)-инструмент прямоугольная область
5. нажать ctrl+shift+c-выделит что именно находиться в выделенном прямоугольнике
6. нажать ctrl+n - создаст новый документ
7. указать содержимое фона: прозрачный фон и ок
8. ctrl+v - вставим картинку
9. ctrl+shift+alt+s - откроет сохранить для web
10. Указать набор png-24 и прозрачность 
11. Сохранить и место куда и имя

---------------------------------------------схема выравнивания псевдоэлемента-------------------------------------------

&::before{
content: '';
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
}

пример:

button {
padding: 0;
font-size: 0;
background: transparent;
width: 27px;
height: 27px;
border-radius: 50%;
border: 1px solid transparent;
position: relative;
&::before{
content: '';
position: absolute;
width: 6px;
height: 6px;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: $default;
border-radius: 50%;
}
}
---------------------------------------------grid-------------------------------------------

Чтобы четко видеть grid-линии нужно в панели разработчика нажать grit-контейнер->grit и так же можно задать цвет
разметки, если выбрать во втором подокне Layout

Свойства которые применяются непосредственно к grid-контейнеру⬇️:

display: grid
Grid представляет собой пересекающийся набор горизонтальных и вертикальных линий, образующих колонки и строки.
Элементы могут быть помещены в grid в пределах линий этих колонок и строк.

display: grid — это CSS-свойство, которое преобразует элемент в контейнер сетки (grid container).
Внутри этого контейнера его дочерние элементы (grid items) располагаются в виде сетки, что позволяет легко управлять
их расположением и размером.

grid-template-columns - свойство grid-template-columns задает количество и ширину столбцов, которые будет занимать
элемент в гриде или сетке.
Единицы измерения:
-> пикселях размеры столбцов будут точно им соответствовать.
->auto, то столбцы будут заполнять размер равный контенту.
->fr (фракция) означает, что все пространство будет разбито на одинаковые доли(преимущество адаптивность).
пример:
grid-template-columns: 200px 200px 200px;
или короткая запись
grid-template-columns: repeat(3, 200px);->кол-во колонок, размер

grid-template-rows - свойство grid-template-rows задает количество и ширину рядов, которые будет занимать элемент в
гриде или сетке.

grid-auto-rows,grid-auto-columns - свойство grid-auto-columns,rows задает ширину столбцов(строк), которые
будет занимать элемент в неявном гриде.Т.е. можно задать размер для одной строки( grid-template-rows: 200px), а потом с
помощью grid-auto-rows задать свойство, которое будет применяться для остальных строк().
Пример:
grid-auto-rows: 125px 225px;
для того чтобы задать не явным ячейкам нужный размер можно применить grid-auto-rows,
т.е. не важно сколько их еще будет высота все равно будет 125px
Если написать более одного значения то высота будет повторяться: первый ряд будет 125px, а второй будет 225px


minmax() это CSS функция, определяющая диапазон размеров, который больше или равен min или растянется до max.
Аналогично min-width и max-width, но только для grit-self.
пример:
grid-template-columns: repeat(3,minmax(100px,200px));


SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
gap - свойство gap задает расстояние между элементами в гриде. В значении свойства в элементе-родителе указываем нужное
нам расстояние с единицами измерения - px, % и т.п.
или есть альтернативные свойства grid-column-gap и grid-row-gap

justify-items - свойство justify-items задает выравнивание элементов внутри ячеек grid по горизонтальной оси.Применяется
к родительскому элементу.
align-items - свойство align-items задает выравнивание элементов вдоль по вертикальной оси для grid и поперечной оси
для flex блоков. Применяется к родительскому элементу.
SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
place-items: end start;
place-items: stretch;

auto - столбцы с auto подстраиваются под контент, занимая минимально необходимое пространство. Это не значит что 2 auto
будут равны(auto не значит равная часть) размер в auto высчитывается относительно заполняемого объема ячейки
пример: grid-template-columns: 1fr auto auto;
1fr -равная часть, выберут самую большую ячейку и от размера её сделают для каждой ячейки такой размер.

SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
свойства можно объединять вот некоторые, которые часто применяються из них:
grid-template: стрки/столбцы
grid-template: 300px 300px 300px/ 1fr 1fr 1fr;
grid-template:repeat(3, 300px)/ repeat(3, 1fr);

grid-auto-flow-Свойство задает автоматическое размещение элементов в гриде. Может иметь значения row -
заполняет ряды элементами(вниз), column - столбцы(вправо) dense - размещает элементы на все пустые места в сетке; row dense -
располагает элементы, заполняя каждый ряд и все свободные места сетки; column dense - заполняет элементами каждый
столбец и все свободное место в гриде.

Grid-линиям можно задать имена в квадратных скобка
grid-template-columns:[col1] 400px [col-item2] 400px [sth3] 400px [four];
grid-template-rows:[row1] 100px [row-item2] 300px [ath3] 150px [five];

grid-template-areas - Свойство grid-template-areas задает размещение элементов в гриде. Вначале каждому элементу-потомку
задаем имя с помощью свойства grid-area. Затем в элементе-родителе мы указываем свойство grid-template-areas, в котором
перечисляем имена элементов-потомков в том порядке, в каком хотим их разместить в гриде.
Пример 1:
grid-template-areas:
'a a b'
'a a b'
'c c b';

Пример 2:
.wrapper {
display: grid;
grid-template-rows: 10vh 80vh 10vh;
grid-template-columns: minmax(200px, 300px) auto;
grid-template-areas:
'h h'
'a c'
'f f';}

.header {
grid-area: h;}
.aside {
grid-area: a;}
.content {
grid-area: c;}
.footer {
grid-area: f;}



Свойства которые применяються непосредственно к grid-элементам⬇️

align-self - свойство align-self задает выравнивание вдоль по вертикальной оси для отдельного элемента в гриде и по
поперечной оси для отдельно взятого flex-блока. По сути данное свойство представляет собой свойство align-items, но для
конкретного блока.
auto - элемент наследует значение от align-items контейнера сетки или, если не задано, stretch.
start,flex-start - выравнивает элемент к началу контейнера (вверх).
end,flex-end - выравнивает элемент к концу контейнера (вниз).
center - выравнивает элемент по центру контейнера.
stretch - растягивает элемент, чтобы заполнить ячейку по высоте (если это возможно).

justify-self - cвойство justify-self задает выравнивание отдельного элемента в гриде по горизонтальной оси. Свойство
применяется в том элементе, который мы хотим выравнять. это свойство будет игнарировать свойство для grid-контейнера justify-items

grid-column-start,grid-row-start - свойство задает начальную позицию элемента в гриде или сетке по столбцам(рядам).
grid-column-end,grid-row-end - свойство задает конечну позицию элемента в гриде или сетке по столбцам(рядам).
Отрицательное значение(-1) говорит что это последная линия, значение(-2)-говорит что предпоследнее значение
span- это называеться track, т.е. увеличение на число ячеек
SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
grid-column: start/end
grid-column: 1/4;
grid-row: 1/-1;
grid-row: 1/span 2;

grid-area - свойство задает имя элементу в гриде. Эти имена указываются в свойстве grid-template-areas, в котором
перечисляются имена элементов в том порядке, в котором их нужно разместить в гриде.
Пример:
grid-area: a;
grid-area: b;
grid-area: c;
































































































































Полезные ссылки:

1. Рыбные картинки
   https://dummyimage.com/
2. CSS reset
   http://html5doctor.com/html-5-reset-stylesheet/
3. Справочник
   https://webref.ru/
4. Шпаргалка по флексам -
   https://habr.com/ru/post/313938/
5. тренажер по флексам
   https://the-echoplex.net/flexyboxes/
6. Slick Slider -
   https://kenwheeler.github.io/slick/
7. normalize:
   https://necolas.github.io/normalize.css/
8. Название классов:
   https://github.com/yoksel/common-words
9. emmet сокращения:
   https://docs.emmet.io/abbreviations/syntax/
10. Google шрифты:
    https://fonts.google.com
11. MixItUp -кнопки фильтра:
    https://www.kunkalabs.com/mixitup/
12. fancybox -для открытия видео:
    https://fancyapps.com/fancybox/3/
    https://daruse.ru/podklyuchenie-i-nastrojka-fancybox
13. Плавный скролл:
    https://webcomplex.com.ua/jquery/plavnyj-skroll-posle-nazhatiya-na-yakornuyu-ssylku.html
14. Фоновые шрифты уже не актуальны лучше использовать svg
FontAwesome: https://fontawesome.com/
    https://icomoon.io/app/#/select/library
15. установка slick-slider
https://kenwheeler.github.io/slick/
$ npm install --save-dev slick-carousel


